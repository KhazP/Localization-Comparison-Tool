# LocalizerAppMain Wiki

## Wiki Structure

- Home
- Architecture
- Key Components
  - File Input Component
  - Results View Component
  - Statistics Panel Component
  - Settings Dialog Component
  - Onboarding Tutorial
- Theme System
- Configuration System
- Parsers
- Developer Guide
- Testing Guide

## Home

```markdown
# LocalizerAppMain

**An Open-Source Localization File Comparison Tool**

A modern, cross-platform tool built with [Flet](https://flet.dev/) for comparing and analyzing localization files. This tool helps streamline the localization process by making it easy to identify differences between translation files.

## Features

- **Multi-Format Support**: Works with CSV, XML, JSON, YAML, .lang, and more
- **Comparison Analysis**: Quickly see added, missing, and unchanged strings
- **Machine Translation**: Optional integration with Google Cloud Translation API
- **Customizable UI**: Multiple themes and accessibility options
- **Cross-Platform**: Works on Windows, macOS, and Linux

## Getting Started

1. Select source and target localization files
2. Configure comparison settings if needed
3. Click "Compare" to analyze differences
4. View results organized by namespace
5. Filter results as needed

## Screenshots

![Main interface](screenshots/main_screen.png)
```

## Architecture

```markdown
# Architecture

LocalizerAppMain follows a component-based architecture with a central application class that coordinates between various UI components and services.

## High-Level Architecture

```
┌─────────────────────────────────────┐
│               App                   │
│  (Main application coordination)    │
└───────────────┬─────────────────────┘
                │
       ┌────────┴─────────┐
       ▼                  ▼
┌─────────────┐    ┌────────────┐
│   Services  │    │ Components │
└──────┬──────┘    └─────┬──────┘
       │                 │
       ▼                 ▼
┌─────────────┐    ┌────────────┐
│File Cache   │    │File Input  │
│Logger       │    │Results View│
│Translation  │    │Stats Panel │
│Config       │    │Settings    │
└─────────────┘    └────────────┘
```

## Core Classes

### App Class
The central `App` class in `GUI/flet_gui.py` initializes the application, manages state, and coordinates between components. It:
- Loads configuration
- Manages theme settings
- Instantiates UI components
- Handles file comparison logic
- Updates the UI based on results

### Component Pattern
Components encapsulate specific UI functionality:
- Each component has its own initialization, UI creation, and event handling
- Components communicate with the main App through references
- Components can update their UI independently

### Service Pattern
Utility services provide core functionality:
- `file_cache_service`: Handles efficient file loading and caching
- `logger_service`: Centralized logging
- `file_processing_service`: File parsing and comparison logic

## Data Flow

1. User selects source and target files through the FileInputComponent
2. App validates files and determines formats
3. Parsers extract key-value pairs from files
4. Comparison logic identifies differences
5. Results are formatted and displayed through ResultsViewComponent
6. StatsPanelComponent shows summary information

## Configuration Management

The `ConfigManager` loads user settings from a JSON file and provides defaults. Components observe changes through callbacks when settings are updated.
```

## Key Components

```markdown
# Key Components

LocalizerAppMain is built around several key UI components that work together to provide a cohesive user experience.

## Component Overview

Each component encapsulates a specific part of the UI and its related functionality:

| Component | Purpose | Key Files |
|-----------|---------|-----------|
| File Input | Manages file selection and preview | `components/file_input.py` |
| Results View | Displays comparison results | `components/results_view.py` |
| Stats Panel | Shows statistics about comparison | `components/stats_panel.py` |
| Settings Dialog | Manages user preferences | `components/settings_dialog.py` |
| Onboarding Tutorial | Guides new users | `components/onboarding.py` |
| History Dialog | Shows comparison history | `components/history_dialog.py` |

Each component maintains its own internal state and UI elements while communicating with the main App class through a reference passed during initialization.
```

### File Input Component

```markdown
# File Input Component

The File Input Component handles the selection and validation of source and target localization files.

## Structure

Located in `components/file_input.py`, this component:
- Creates file selection UI for source and target files
- Integrates with the FilePicker API
- Provides file previews
- Validates selected files are compatible

## Key Features

- **Asynchronous file loading**: Uses file_cache_service for efficient file operations
- **File size and line count**: Displays metadata about selected files
- **File previews**: Shows content previews when enabled
- **File validation**: Checks if selected files are valid for comparison

## Code Structure

```python
class FileInputComponent:
    def __init__(self, page: ft.Page, app_reference):
        # Initialize properties and UI elements
        
    def _create_file_input(self, label: str, is_source=True) -> Container:
        # Create file input container with browse button
        
    def handle_file_picked(self, e: FilePickerResultEvent, field, icon, clear_btn, field_type):
        # Handle file selection events
        
    def update_file_preview(self, file_path: str, field_type: str):
        # Update preview text fields with file content
```

## UI Layout

The component creates two identical file input areas with:
- Text label ("Source File" or "Target File")
- Browse button with hover effects
- Display area showing selected file name, size, and lines
- File icon that changes color based on selection state

## Responsive Layout

The component uses a responsive layout with:
- Full width on mobile (< 768px)
- Side by side on desktop (> 768px)

## Customization

The component adapts to the current theme, updating colors for:
- Text fields
- Borders
- Icons
- Background elements

## Events

The component exposes several events:
- `open_source_picker`: Opens file picker for source files
- `open_target_picker`: Opens file picker for target files
```

### Results View Component

```markdown
# Results View Component

The Results View Component displays the comparison results between source and target files, highlighting additions, removals, and unchanged items.

## Structure

Located in `components/results_view.py`, this component:
- Creates a formatted display of comparison results
- Provides filtering and search capabilities
- Groups results by namespace (optional)
- Provides expand/collapse functionality

## Key Features

- **Grouped display**: Organizes results by namespace for better readability
- **Search functionality**: Quickly filter results by text
- **Copy functionality**: Copy results to clipboard
- **Expand/collapse sections**: Toggle visibility of namespaces
- **Line number display**: Shows source file line numbers when available

## Code Structure

```python
class ResultsViewComponent:
    def __init__(self, page: ft.Page, app_reference, colors: dict):
        # Initialize properties and UI elements
        
    def build_results_table(self, comparison_result: str):
        # Convert raw comparison results to UI elements
        
    def filter_results(self, query: str):
        # Filter displayed results based on user search
        
    def group_keys_by_namespace(self, lines: list[str]) -> dict:
        # Organize results into namespace groups
        
    def toggle_expand_all(self, e):
        # Toggle visibility of namespace sections
```

## Results Display

Results are displayed with visual indicators:
- `+` (green) - New keys in target file
- `-` (red) - Missing keys in target file
- `~` (yellow) - Modified values
- No indicator - Identical keys and values

## Performance Considerations

For large files, the component:
- Uses efficient filtering algorithms
- Lazily builds UI elements
- Preserves original results for filtering operations

## Customization

The component adapts to the current theme and user preferences:
- Colors for different result types
- Displaying line numbers (controlled by settings)
- Grouping results by namespace (controlled by settings)
```

### Statistics Panel Component

```markdown
# Statistics Panel Component

The Statistics Panel Component provides a visual overview of comparison results with key metrics.

## Structure

Located in `components/stats_panel.py`, this component:
- Displays summary statistics about the comparison
- Shows total keys, missing keys, obsolete keys, and translation percentage
- Updates dynamically as comparisons are performed

## Key Features

- **Visual metrics**: Displays key statistics with appropriate colors
- **Percentage calculation**: Shows translation completion percentage
- **Responsive layout**: Adapts to different screen sizes

## Code Structure

```python
class StatsPanelComponent:
    def __init__(self, page: ft.Page, app_reference, colors: dict):
        # Initialize properties and UI elements
        
    def _create_stats_panel(self):
        # Create the main stats panel with all metrics
        
    def _create_stat_container(self, label: str, stat_text: Text, col=None):
        # Create individual stat containers
        
    def update_stats(self, total_keys: int, missing_keys: int, obsolete_keys: int):
        # Update displayed statistics
```

## UI Layout

The Statistics Panel is a card-based component with:
- Responsive row layout using ResponsiveRow
- Individual stat containers with label and value
- Color coding for different metrics (total, missing, extra, percentage)

## Metrics Display

The component shows several key metrics:
- **Total Keys**: Total number of unique keys across both files
- **Missing in Target**: Keys present in source but missing from target
- **Missing in Source**: Keys present in target but missing from source (obsolete)
- **Translated %**: Percentage of keys that are properly translated

## Interactions

This component is primarily informational but does update dynamically:
- Updates immediately after comparison is run
- Changes color scheme when theme is changed
- Adapts layout based on screen size

## Customization

The component adapts to the current theme with:
- Card background color
- Text colors for labels and values
- Accent colors for different metrics
```

### Settings Dialog Component

```markdown
# Settings Dialog Component

The Settings Dialog Component provides a comprehensive interface for configuring application preferences and behavior.

## Structure

Located in `components/settings_dialog.py`, this component:
- Creates a tabbed settings interface
- Manages user preferences
- Saves configuration to persistent storage
- Provides immediate visual feedback for changes

## Key Features

- **Tabbed interface**: Organizes settings into logical categories
- **Animated transitions**: Smooth animations between tabs
- **Persistent storage**: Saves settings to disk
- **Accessibility options**: Provides options for improved accessibility
- **Theme customization**: Allows selection of multiple themes

## Code Structure

```python
class SettingsDialogComponent:
    def __init__(self, page: ft.Page, app_reference, config: Dict[str, Any], colors: dict):
        # Initialize properties and UI elements
        
    def _create_general_tab(self) -> Container:
        # Create general settings tab
        
    def _create_comparison_tab(self) -> Container:
        # Create comparison settings tab
        
    def _create_file_format_tab(self) -> Container:
        # Create file format settings tab
        
    def _create_translation_tab(self) -> Container:
        # Create translation settings tab
        
    def _create_accessibility_tab(self) -> Container:
        # Create accessibility settings tab
        
    def switch_to_tab(self, index):
        # Handle tab switching with animations
        
    def handle_setting_change(self, e, setting_name):
        # Update configuration when setting changes
```

## Settings Tabs

The component organizes settings into five tabs:

1. **General**
   - Theme selection
   - Animation speed
   - Interface behavior

2. **Comparison**
   - Comparison options
   - Display preferences
   - Advanced comparison settings

3. **File Format**
   - Preferred format selection
   - Ignore patterns
   - Format-specific settings

4. **Translation**
   - Machine translation settings
   - API configuration
   - Language preferences

5. **Accessibility**
   - Visual accessibility options
   - Interaction settings
   - Font size scaling

## Animations

The component features several animations:
- Fade transitions when opening/closing the dialog
- Smooth transitions between tabs
- Visual feedback when changing settings

## Customization

Each tab uses a unique color scheme:
- Green for General
- Blue for Comparison
- Orange for File Format
- Pink for Translation
- Purple for Accessibility

## Settings Persistence

Settings are:
- Automatically saved when changed
- Loaded at application startup
- Stored in a JSON configuration file
```

### Onboarding Tutorial

```markdown
# Onboarding Tutorial

The Onboarding Tutorial provides a step-by-step introduction for new users, highlighting key features and workflows.

## Structure

Located in `components/onboarding.py`, this component:
- Creates a multi-step tutorial dialog
- Guides users through basic application features
- Provides visual cues and examples
- Tracks tutorial completion state

## Key Features

- **Multi-step progression**: Walks users through features in logical order
- **Visual indicators**: Shows progress through steps
- **Interactive elements**: Allows users to navigate steps freely
- **Persistent state**: Remembers if tutorial has been completed

## Code Structure

```python
class OnboardingTutorial:
    def __init__(self, page: ft.Page, app_reference):
        # Initialize properties and tutorial steps
        
    def _create_header(self):
        # Create tutorial header with step title
        
    def _create_content(self):
        # Create content area with step description and illustration
        
    def _create_navigation(self):
        # Create navigation controls with progress indicators
        
    def update_step(self):
        # Update UI for current tutorial step
        
    def next_step(self, e=None):
        # Advance to next tutorial step
        
    def start_tutorial(self):
        # Begin tutorial sequence
        
    def end_tutorial(self, e=None):
        # Complete tutorial and save progress
```

## Tutorial Steps

The tutorial consists of several steps:

1. **Welcome**: Introduction to the application
2. **Select Files**: How to select source and target files
3. **Compare Files**: Using the compare button to analyze differences
4. **View Results**: Understanding the results display
5. **Machine Translation**: Using automatic translation features

## Progress Tracking

The tutorial tracks user progress with:
- Visual step indicators
- Progress bar showing completion percentage
- Ability to jump to previous steps
- Option to skip the tutorial entirely

## Animations

The tutorial includes several animations:
- Fade-in when starting the tutorial
- Transitions between steps
- Highlighting of UI elements
- Fade-out when completing the tutorial

## Customization

The tutorial adapts to the current theme:
- Background and text colors follow theme
- Each step has its own accent color
- Icons and illustrations match step content
```

## Theme System

```markdown
# Theme System

LocalizerAppMain features a comprehensive theme system that provides visual customization across the entire application.

## Structure

The theme system is defined in `core/themes.py` and consists of:
- Multiple predefined themes
- Color palettes for different UI elements
- Dynamic theme switching
- System theme integration

## Predefined Themes

The application includes several built-in themes:

| Theme | Description | Primary Colors |
|-------|-------------|----------------|
| Dark | Default dark theme | Dark grays with blue accents |
| Light | Standard light theme | White with blue accents |
| Amoled | True black theme | Pure black with blue highlights |
| High Contrast | Accessibility theme | Maximum contrast for readability |
| Minimalist | Clean interface | Subtle grays with teal accents |
| Earth Tones | Nature-inspired | Browns and greens |
| Pastel | Soft color palette | Gentle pastel hues |

## Theme Structure

Each theme defines colors for:

```python
{
    "bg": {
        "primary": "#RRGGBB",    // Primary background
        "secondary": "#RRGGBB",  // Secondary background 
        "input": "#RRGGBB",      // Input field background
        "accent": "#RRGGBB",     // Accent color
    },
    "text": {
        "primary": "#RRGGBB",    // Primary text
        "secondary": "#RRGGBB",  // Secondary text
        "accent": "#RRGGBB",     // Accent text
    },
    "border": {
        "default": "#RRGGBB",    // Default borders
        "accent": "#RRGGBB",     // Accent borders
    },
    "changes": {
        "added": "#RRGGBB",      // Added items (green)
        "removed": "#RRGGBB",    // Removed items (red)
        "modified": "#RRGGBB"    // Modified items (yellow)
    }
}
```

## Theme Switching

Users can change themes through the Settings Dialog:
- Quick theme buttons for common themes
- Theme dropdown for all available themes
- System theme integration option

## Implementation

The theme system is implemented with:

1. **Theme Definition**: Central theme definitions in `core/themes.py`
2. **Theme Selection**: User selection stored in configuration
3. **Theme Application**: `update_theme_colors()` method in App class
4. **Component Updates**: Each component implements `update_colors()` method
5. **Color Caching**: Colors are cached for performance

## Code Example

```python
# Apply a new theme
def handle_theme_change(self, e):
    self.current_theme = e.control.value
    self.config["theme"] = self.current_theme
    ConfigManager.save(self.config)
    self.update_theme_colors()
    
# Update colors throughout the application
def update_theme_colors(self):
    if self.current_theme in self._cached_colors:
        self.COLORS = self._cached_colors[self.current_theme]
    else:
        self.COLORS = self.THEMES[self.current_theme]
        self._cached_colors[self.current_theme] = self.COLORS
        
    # Update page theme
    if self.current_theme == "system":
        self.page.theme_mode = ft.ThemeMode.SYSTEM
    elif self.current_theme in ["dark", "amoled"]:
        self.page.theme_mode = ft.ThemeMode.DARK
    else:
        self.page.theme_mode = ft.ThemeMode.LIGHT
    
    # Update components
    self.file_input.update_colors(self.COLORS)
    self.results_view.update_colors(self.COLORS)
    self.stats_panel.update_colors(self.COLORS)
```

## Accessibility Considerations

The theme system includes specific accessibility features:
- High contrast theme for vision impairments
- System theme integration for OS-level accessibility settings
- Font size scaling independent of theme selection
```

## Configuration System

```markdown
# Configuration System

LocalizerAppMain uses a flexible configuration system that manages user preferences and application settings.

## Structure

The configuration system is built around the `ConfigManager` class in config.py, which provides:
- Default configuration values
- Loading saved settings
- Saving user preferences
- Merging defaults with user settings

## Configuration Properties

The application stores various configuration settings:

| Category | Settings | Description |
|----------|----------|-------------|
| **Theme** | theme, custom_theme | Visual appearance settings |
| **Comparison** | auto_fill_missing, log_missing_strings, ignore_patterns | How files are compared |
| **Format** | preferred_format, ignore_whitespace, ignore_case | Format-specific options |
| **Display** | show_preview, show_line_numbers, group_by_namespace | How results are shown |
| **Translation** | mt_enabled, mt_api_key, mt_source_lang, mt_target_lang | Machine translation options |
| **Accessibility** | high_contrast, large_text, font_size_scale | Accessibility options |
| **UX** | animation_speed, confirm_actions, enable_keyboard_nav | User experience settings |

## Default Configuration

The application provides sensible defaults for all settings:

```json
{
    "auto_fill_missing": false,
    "log_missing_strings": false,
    "ignore_patterns": [],
    "preferred_format": "auto",
    "ignore_whitespace": false,
    "ignore_case": false,
    "compare_values": true,
    "group_by_namespace": true,
    "show_preview": false,
    "show_line_numbers": false,
    "mt_enabled": false,
    "mt_api_key": "",
    "mt_source_lang": "en",
    "mt_target_lang": "tr",
    "theme": "system",
    "custom_theme": "minimalist",
    "enable_keyboard_nav": true,
    "high_contrast": false,
    "large_text": false,
    "font_size_scale": 1.0,
    "page_size": 50,
    "use_infinite_scroll": true,
    "max_history_entries": 100,
    "tutorial_completed": true
}
```

## Implementation

The configuration is managed through:

1. **Initialization**: App loads configuration during startup
2. **UI Binding**: Settings dialog connects to configuration values
3. **Event Handling**: Changes trigger real-time UI updates
4. **Persistence**: Changes are saved to disk automatically

## Code Example

```python
# Configuration Manager
class ConfigManager:
    CONFIG_FILE = "config/config.json"
    
    @staticmethod
    def load():
        """Load configuration or return defaults if not found"""
        try:
            if os.path.exists(ConfigManager.CONFIG_FILE):
                with open(ConfigManager.CONFIG_FILE, 'r') as f:
                    return json.load(f)
        except Exception as e:
            logger.error(f"Error loading config: {str(e)}")
        return {}
        
    @staticmethod
    def save(config):
        """Save configuration to disk"""
        try:
            os.makedirs(os.path.dirname(ConfigManager.CONFIG_FILE), exist_ok=True)
            with open(ConfigManager.CONFIG_FILE, 'w') as f:
                json.dump(config, f, indent=4)
        except Exception as e:
            logger.error(f"Error saving config: {str(e)}")
```

## Settings Integration

The configuration system integrates with the UI through the Settings Dialog:
- Each setting is bound to UI controls
- Changes immediately update the application state
- Settings are persisted between application launches
- Changes trigger appropriate UI updates
```

## Parsers

```markdown
# Parsers

LocalizerAppMain supports multiple file formats through a modular parser system that extracts key-value pairs from localization files.

## Structure

The parser system uses an inheritance hierarchy with a base parser class and format-specific implementations:

```
┌──────────────────┐
│ TranslationParser│
└────────┬─────────┘
         │
    ┌────┴─────────────┬──────────────┬──────────────┬──────────────┐
    ▼                  ▼              ▼              ▼              ▼
┌─────────┐      ┌──────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│JSONParser│      │XMLParser │    │CSVParser│    │YAMLParser│    │LangParser│
└─────────┘      └──────────┘    └─────────┘    └─────────┘    └─────────┘
```

## Base Parser

The `TranslationParser` base class in `parsers/base_parser.py` defines the common interface:

```python
class TranslationParser:
    """Base class for all translation file parsers."""
    
    def parse(self, content: str) -> Dict[str, str]:
        """
        Parse content into a dictionary of translations.
        
        Args:
            content: String content to parse
            
        Returns:
            Dictionary mapping keys to translated strings
        """
        raise NotImplementedError("Subclasses must implement parse()")
        
    def format(self, translations: Dict[str, str]) -> str:
        """
        Format translations dictionary back into a string.
        
        Args:
            translations: Dictionary of translations
            
        Returns:
            Formatted string representation
        """
        raise NotImplementedError("Subclasses must implement format()")
```

## Supported Formats

The application includes parsers for common localization formats:

| Format | Parser | File Extensions | Description |
|--------|--------|----------------|-------------|
| JSON | JSONParser | .json | Standard JSON format |
| XML | XMLParser | .xml, .resx | XML-based formats |
| CSV | CSVParser | .csv | Comma-separated values |
| YAML | YAMLParser | .yaml, .yml | YAML format |
| LANG | LangParser | .lang | Key-value format with equals sign |
| Properties | PropertiesParser | .properties | Java properties format |

## Example: CSV Parser

The CSV Parser implementation handles CSV files with configurable options:

```python
class CSVParser(TranslationParser):
    def __init__(self, 
                 delimiter: str = ',',
                 has_header: bool = True,
                 key_column: Union[str, int] = 'key',
                 value_column: Union[str, int] = 'value',
                 quoting: int = csv.QUOTE_MINIMAL):
        """
        Initialize CSV parser with configurable options.
        
        Args:
            delimiter: CSV field delimiter (default: ',')
            has_header: Whether CSV has header row (default: True)
            key_column: Column name or index for keys (default: 'key')
            value_column: Column name or index for values (default: 'value')
            quoting: CSV quoting style (default: QUOTE_MINIMAL)
        """
        self.delimiter = delimiter
        self.has_header = has_header
        self.key_column = key_column
        self.value_column = value_column
        self.quoting = quoting
```

## Format Detection

The application automatically detects file formats using:
1. **File extension**: Primary method for format identification
2. **Content analysis**: Fallback detection by examining file content
3. **User preference**: Override with preferred format from settings

## Error Handling

The parser system includes robust error handling:
- Format-specific error classes
- Detailed error messages with line information
- Graceful fallback on parsing failures
- User-friendly error display
```

## Developer Guide

```markdown
# Developer Guide

This guide provides information for developers who want to contribute to or understand the LocalizerAppMain project.

## Project Structure

```
LocalizerAppMain/
├── GUI/                    # GUI implementation
│   ├── flet_gui.py         # Main application class
│   └── logic.py            # Business logic
├── components/             # UI components
│   ├── __init__.py
│   ├── file_input.py
│   ├── results_view.py
│   ├── settings_dialog.py
│   ├── stats_panel.py
│   ├── onboarding.py
│   └── history_dialog.py
├── core/                   # Core functionality
│   ├── config.py           # Configuration management
│   ├── constants.py        # Application constants
│   ├── errors.py           # Custom exceptions
│   └── themes.py           # Theme definitions
├── parsers/                # File format parsers
│   ├── __init__.py
│   ├── base_parser.py
│   ├── json_parser.py
│   ├── xml_parser.py
│   ├── csv_parser.py
│   └── ...
├── tests/                  # Unit and integration tests
├── utils/                  # Utility services
│   ├── file_cache_service.py
│   ├── logger_service.py
│   ├── file_processing_service.py
│   └── history_manager.py
├── docs/                   # Documentation
└── config/                 # Configuration files
```

## Development Setup

1. **Clone the repository**
   ```bash
   git clone https://github.com/KhazP/LocalizerAppMain.git
   cd LocalizerAppMain
   ```

2. **Set up virtual environment**
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```

3. **Install dependencies**
   ```bash
   pip install -r requirements.txt
   ```

4. **Run the application**
   ```bash
   python -m GUI.flet_gui
   ```

## Architecture Overview

LocalizerAppMain follows these architectural patterns:

### Component Pattern
UI elements are encapsulated in reusable components that:
- Maintain their own internal state
- Expose a clear initialization API
- Handle their own events
- Update their own UI

### Service Pattern
Core functionality is provided by utility services:
- `file_cache_service`: Efficient file handling
- `logger_service`: Centralized logging
- `file_processing_service`: File parsing and processing
- `history_manager`: Comparison history tracking

### Main Application Coordination
The `App` class in flet_gui.py:
- Initializes components and services
- Coordinates between UI and business logic
- Manages application state
- Handles high-level events

## Adding New Features

### New File Format Support
To add support for a new file format:

1. Create a new parser in parsers that extends `TranslationParser`
2. Implement `parse()` and `format()` methods
3. Add format detection in `utils/format_detector.py`
4. Update `SUPPORTED_FORMATS` in constants.py

### New UI Component
To add a new UI component:

1. Create a new file in components
2. Implement class with `__init__` method accepting `page` and `app_reference`
3. Create necessary UI elements and event handlers
4. Add to __init__.py for imports
5. Instantiate in `App.__init__()` in flet_gui.py

## UI Design Principles

1. **Responsive Layout**
   - Use `ResponsiveRow` and `col` attributes for responsive grids
   - Design for mobile and desktop viewing
   - Test with different window sizes

2. **Theme Compatibility**
   - Never hardcode colors; use `self.colors` dictionary
   - Implement `update_colors()` method in each component
   - Test with all built-in themes

3. **Accessibility**
   - Provide tooltips for icons
   - Support keyboard navigation
   - Use sufficient contrast ratios
   - Test with screen readers

## Coding Standards

1. **PEP 8** - Follow Python style guide
2. **Docstrings** - Document all classes and methods
3. **Type Hints** - Use typing annotations
4. **Error Handling** - Use custom exceptions and proper error reporting
5. **Testing** - Write unit tests for new functionality
```

## Testing Guide

```markdown
# Testing Guide

This guide explains the testing approach for LocalizerAppMain and how to run and extend the test suite.

## Testing Architecture

The testing system uses:
- **pytest**: Test framework
- **unittest.mock**: Mocking capabilities
- **snapshot testing**: UI component verification

## Test Structure

Tests are organized in the tests directory:

```
tests/
├── __init__.py
├── conftest.py              # Common fixtures
├── test_parsers.py          # Format parser tests
├── test_ui.py               # UI interaction tests
├── test_integration.py      # Integration tests
├── test_snapshots.py        # UI snapshot tests
├── mock_services.py         # Service mocks
├── snapshot_helpers.py      # Snapshot testing utilities
└── snapshots/               # Stored snapshots for comparison
```

## Test Categories

```markdown
### Unit Tests
Test individual components and functions in isolation:
- Parser functionality
- Utility services
- Business logic

### Component Tests
Verify UI components render correctly:
- Visual appearance matching snapshots
- Event handler behavior
- State management

### Integration Tests
Test interactions between components and services:
- End-to-end file comparison
- Configuration management
- Theme switching

## Running Tests

Run the full test suite:
```bash
pytest
```

Run specific test categories:
```bash
pytest tests/test_parsers.py
pytest tests/test_ui.py
pytest tests/test_integration.py
```

Update UI snapshots:
```bash
UPDATE_SNAPSHOTS=true pytest tests/test_snapshots.py
```

## Snapshot Testing

Snapshot testing compares UI components against stored "known-good" representations:

1. The test renders a component with specific props
2. The rendered output is serialized to a JSON representation
3. This is compared to a stored snapshot file
4. Differences indicate UI changes that might be bugs

```python
def test_file_input_component_snapshot(self, test_page, snapshot_comparator):
    """Test file input component matches snapshot"""
    component = FileInputComponent(test_page, mock_app)
    component_dict = format_component(component.build())
    mismatch = snapshot_comparator.compare(component_dict, "file_input_component")
    assert not mismatch, f"Snapshot mismatch:\n{mismatch.diff}"
```

## Mock Objects

Tests use mock objects to isolate components:

```python
@pytest.fixture
def mock_app():
    """Create a mock app with all required attributes"""
    app = Mock()
    app.COLORS = {
        "text": {"primary": "#000000", "secondary": "#666666"},
        "bg": {"accent": "#007BFF", "input": "#FFFFFF"},
        "border": {"default": "#CCCCCC"},
        "changes": {"added": "#4CAF50", "removed": "#F44336"}
    }
    app.config = {"show_preview": False}
    app.update_compare_button = Mock()
    return app
```

## Writing Tests

When adding new features, write appropriate tests:

1. **Unit tests** for new parsers, services, or utility functions
2. **Component tests** for UI elements
3. **Integration tests** for flows combining multiple components
4. **Snapshot tests** for visual regression testing

## Continuous Integration

Tests run automatically on GitHub Actions:
- On every push to main branch
- On all pull requests
- Test failures block merges
```

## File Comparison Logic

```markdown
# File Comparison Logic

The core functionality of LocalizerAppMain is analyzing differences between localization files, implemented primarily in logic.py and related modules.

## Comparison Process

The file comparison follows these steps:

1. **Parse Files**: Convert source and target files into key-value dictionaries
2. **Extract Keys**: Identify all unique keys across both files
3. **Compare Keys**: Find keys present in source but not target (missing)
4. **Compare Keys**: Find keys present in target but not source (obsolete)
5. **Compare Values**: For keys in both files, compare the values
6. **Format Results**: Generate a human-readable comparison report

## Key Comparison Functions

### `parse_content_by_ext()`
Detects file format and delegates to the appropriate parser:

```python
def parse_content_by_ext(content: str, extension: str) -> Dict[str, str]:
    """Parse content based on file extension."""
    if extension.lower() in ('.json'):
        parser = JSONParser()
    elif extension.lower() in ('.xml', '.resx'):
        parser = XMLParser()
    elif extension.lower() in ('.csv'):
        parser = CSVParser()
    # ... other parsers
    else:
        raise ValueError(f"Unsupported file extension: {extension}")
        
    return parser.parse(content)
```

### `compare_translations()`
Core function that compares two translation dictionaries:

```python
def compare_translations(
    target_dict: Dict[str, str],
    source_dict: Dict[str, str],
    ignore_case: bool = False,
    ignore_whitespace: bool = False,
    is_gui: bool = False,
    include_summary: bool = True,
    compare_values: bool = True,
    ignore_patterns: List[str] = None,
    log_missing_keys: bool = False,
    auto_fill_missing: bool = False,
    mt_settings: Dict = None
) -> str:
    """
    Compare source and target translations and generate a report.
    
    Args:
        target_dict: Target translations
        source_dict: Source translations
        ignore_case: Whether to ignore case in comparison
        ignore_whitespace: Whether to ignore whitespace differences
        is_gui: Whether this is being run from the GUI
        include_summary: Whether to include a summary section
        compare_values: Whether to compare values or just keys
        ignore_patterns: List of regex patterns to ignore
        log_missing_keys: Whether to log missing keys
        auto_fill_missing: Whether to auto-fill missing keys
        mt_settings: Machine translation settings
        
    Returns:
        Formatted comparison report
    """
    # Find missing keys (in source but not in target)
    missing_keys = set(source_dict.keys()) - set(target_dict.keys())
    
    # Find obsolete keys (in target but not in source)
    obsolete_keys = set(target_dict.keys()) - set(source_dict.keys())
    
    # Find common keys to compare values
    common_keys = set(source_dict.keys()) & set(target_dict.keys())
    
    # Generate the report
    # ...
```

## Comparison Options

The comparison engine supports multiple options:

| Option | Description |
|--------|-------------|
| ignore_case | Ignore case differences in values |
| ignore_whitespace | Ignore whitespace differences in values |
| compare_values | Compare values or just check key existence |
| ignore_patterns | Skip keys matching specific patterns |
| auto_fill_missing | Copy missing strings from source to target |
| mt_enabled | Use machine translation for missing strings |

## Machine Translation Integration

When enabled, the system can translate missing strings:

```python
def translate_missing_keys(
    source_dict: Dict[str, str],
    target_dict: Dict[str, str],
    source_lang: str,
    target_lang: str,
    api_key: str,
    progress_callback=None
) -> Tuple[Dict[str, str], List[str]]:
    """
    Translate missing keys from source to target language.
    
    Args:
        source_dict: Source translations
        target_dict: Target translations
        source_lang: Source language code
        target_lang: Target language code
        api_key: Google Cloud API key
        progress_callback: Function to call with progress updates
        
    Returns:
        Tuple of updated target dict and list of error messages
    """
    # ... implementation ...
```

## Results Processing

The comparison results are formatted for display:

1. **Line-by-line format**: Each key gets a prefix indicating its status
   - `+` for additions (in source but not target)
   - `-` for removals (in target but not source)
   - `~` for modifications (different values)
   - No prefix for identical entries

2. **Grouping by namespace**: Keys are grouped by their namespace for better organization
   - `common.cancel: Cancel` and `common.ok: OK` are grouped under "common"
   - Results are sorted alphabetically within groups

## Performance Optimizations

For large files, several optimizations are implemented:

1. **File caching**: Recently accessed files are cached
2. **Asynchronous processing**: Long operations run in background threads
3. **Lazy loading**: Parts of large files are loaded on demand
4. **Progress reporting**: User gets feedback during long operations
```

## Accessibility Features

```markdown
# Accessibility Features

LocalizerAppMain includes numerous accessibility features to ensure the application is usable by people with diverse needs and abilities.

## Visual Accessibility

### Themes and Contrast

- **High Contrast Mode**: Dedicated theme with maximum contrast ratios
- **Dark/Light Themes**: Options for different lighting conditions
- **AMOLED Theme**: True black theme for OLED screens

### Text and Font Options

- **Scalable Text**: Adjustable font size scaling from 1.0x to 2.0x
- **Large Text Mode**: Increases all text by 25% for improved readability
- **Font Selection**: Consistent use of readable fonts (Roboto, Consolas)

### Color Considerations

- **Color Blindness**: Icons use both color and shape to convey meaning
- **Meaningful Colors**: Red/green/yellow used consistently for status
- **Non-Color Indicators**: All information conveyed by color also has text or icon indicators

## Keyboard Accessibility

### Navigation

- **Tab Navigation**: Full keyboard navigation support
- **Keyboard Shortcuts**: Common actions have keyboard shortcuts
- **Focus Indicators**: Visible focus indicators for all interactive elements

### Settings

- **Keyboard Navigation Setting**: Option to enable/disable keyboard navigation
- **Persistent Settings**: Accessibility preferences are saved between sessions

## Screen Reader Support

- **Proper Labels**: All controls have descriptive labels
- **ARIA Attributes**: Used where appropriate for improved screen reader experience
- **Semantic Markup**: Content organized for logical reading order

## Implementation Details

### High Contrast Mode

```python
def handle_contrast_change(self, e):
    """Handle high contrast mode toggle"""
    self.config["high_contrast"] = e.control.value
    if e.control.value:
        self.COLORS = self.THEMES["high_contrast"]
        # Force update all text colors for high contrast
        self.page.theme = ft.Theme(
            color_scheme_seed=Colors.BLUE_GREY,
            font_family="Roboto",
            visual_density=ft.ThemeVisualDensity.COMFORTABLE,
        )
    else:
        self.COLORS = self.THEMES[self.current_theme]
    
    self.update_theme_colors()
    self.update_text_sizes()  # Also update text sizes to maintain accessibility
    self.page.update()
```

### Font Size Scaling

```python
def update_all_text_sizes(self):
    """Update text sizes throughout the application"""
    scale = self.config["font_size_scale"]
    if self.config["large_text"]:
        scale *= 1.25

    # Base sizes for different text types
    base_sizes = {
        "small": 12,
        "normal": 14,
        "large": 16,
        "header": 32,
        "title": 24
    }

    def update_control_text_size(control):
        """Recursively update text sizes in controls"""
        if isinstance(control, Text):
            # Apply appropriate scaling based on text role
            if control.weight == "bold" and control.size >= 24:
                control.size = int(base_sizes["title"] * scale)
            elif control.weight == "bold":
                control.size = int(base_sizes["large"] * scale)
            else:
                control.size = int(base_sizes["normal"] * scale)
```

### Keyboard Navigation

```python
def update_keyboard_navigation(self):
    """Update keyboard navigation settings by attaching or detaching the event handler."""
    if self.config.get("enable_keyboard_nav"):
        self.register_keyboard_navigation()
    else:
        self.unregister_keyboard_navigation()
    self.page.update()
```

## Testing Accessibility

The application includes automated and manual testing for accessibility:

1. **Color Contrast**: Automated tests verify contrast ratios meet WCAG standards
2. **Keyboard Navigation**: Tests verify all functionality is accessible by keyboard
3. **Screen Reader**: Manual testing with screen readers ensures proper operation
4. **Font Scaling**: Tests verify UI adapts to various font sizes without breaking

## Continued Improvement

Accessibility is an ongoing process with:
- Regular accessibility audits
- User feedback collection
- Updates to follow best practices
```

## Services

```markdown
# Services

LocalizerAppMain implements a service-oriented architecture for core functionality, separating concerns and improving maintainability.

## Service Pattern

Services in LocalizerAppMain:
- Provide centralized access to specific functionality
- Implement singleton pattern for global access
- Handle resource management and cleanup
- Abstract implementation details from application code

## Core Services

### Logger Service

The `logger_service` provides centralized logging functionality:

```python
class LoggerService:
    def __init__(self):
        self._loggers = {}
        
    def get_logger(self, name="root"):
        """Get a logger instance with the given name."""
        if name not in self._loggers:
            logger = logging.getLogger(name)
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)
            logger.setLevel(logging.INFO)
            self._loggers[name] = logger
            
        return self._loggers[name]
```

### File Cache Service

The `file_cache_service` optimizes file operations:

```python
class FileCacheService:
    def __init__(self):
        self._file_cache = {}
        self._line_counts = {}
        self._file_stats = {}
        
    def read_file(self, file_path):
        """Read a file with caching for better performance."""
        if file_path in self._file_cache:
            return self._file_cache[file_path]
            
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                self._file_cache[file_path] = content
                return content
        except UnicodeDecodeError:
            with open(file_path, 'r', encoding='latin-1') as f:
                content = f.read()
                self._file_cache[file_path] = content
                return content
                
    def count_lines(self, file_path):
        """Count lines in a file with caching."""
        if file_path in self._line_counts:
            return self._line_counts[file_path]
            
        count = sum(1 for _ in open(file_path, 'rb'))
        self._line_counts[file_path] = count
        return count
        
    def preview_file(self, file_path, line_count=5):
        """Get a preview of a file's contents."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = [next(f, '').rstrip() for _ in range(line_count)]
                return '\n'.join(lines) + ('\n...' if len(lines) == line_count else '')
        except Exception as e:
            return f"Error reading file: {str(e)}"
```

### File Processing Service

The `file_processing_service` handles asynchronous file operations:

```python
class FileProcessingService:
    def __init__(self):
        self._tasks = {}
        self._next_task_id = 1
        
    def compare_files_async(self, source_path, target_path, config, progress_callback=None):
        """Start asynchronous file comparison."""
        task_id = str(self._next_task_id)
        self._next_task_id += 1
        
        def task():
            try:
                # Read files
                with open(source_path, 'r', encoding='utf-8') as f:
                    source_content = f.read()
                with open(target_path, 'r', encoding='utf-8') as f:
                    target_content = f.read()
                    
                # Parse content
                ext_source = Path(source_path).suffix.lower()
                ext_target = Path(target_path).suffix.lower()
                
                source_result = logic.parse_content_by_ext(source_content, ext_source)
                target_result = logic.parse_content_by_ext(target_content, ext_target)
                
                # Extract dictionaries and line numbers
                source_dict = source_result["translations"] if isinstance(source_result, dict) else source_result
                target_dict = target_result["translations"] if isinstance(target_result, dict) else target_result
                
                source_lines = source_result.get("line_numbers", {}) if isinstance(source_result, dict) else {}
                target_lines = target_result.get("line_numbers", {}) if isinstance(target_result, dict) else {}
                
                # Compare translations
                comparison_result = logic.compare_translations(
                    target_dict,
                    source_dict,
                    ignore_case=config["ignore_case"],
                    ignore_whitespace=config["ignore_whitespace"],
                    is_gui=True,
                    include_summary=True,
                    compare_values=config["compare_values"],
                    ignore_patterns=config["ignore_patterns"],
                    log_missing_keys=config["log_missing_strings"],
                    auto_fill_missing=config["auto_fill_missing"]
                )
                
                # Calculate statistics
                missing_keys = len(set(source_dict.keys()) - set(target_dict.keys()))
                obsolete_keys = len(set(target_dict.keys()) - set(source_dict.keys()))
                total_keys = len(source_dict)
                
                # Store results
                self._tasks[task_id] = {
                    'status': 'completed',
                    'result': {
                        'comparison': comparison_result,
                        'source_dict': source_dict,
                        'target_dict': target_dict,
                        'source_lines': source_lines,
                        'target_lines': target_lines,
                        'stats': {
                            'total_keys': total_keys,
                            'missing_keys': missing_keys,
                            'obsolete_keys': obsolete_keys
                        }
                    }
                }
            except Exception as e:
                self._tasks[task_id] = {
                    'status': 'error',
                    'error': str(e)
                }
                
        # Start the task in a thread
        thread = threading.Thread(target=task)
        thread.start()
        
        # Store initial task state
        self._tasks[task_id] = {'status': 'running'}
        
        return task_id
        
    def is_task_complete(self, task_id):
        """Check if a task is complete."""
        if task_id not in self._tasks:
            return True
        return self._tasks[task_id]['status'] in ['completed', 'error']
        
    def get_task_status(self, task_id):
        """Get the status and result of a task."""
        if task_id not in self._tasks:
            return {'status': 'unknown'}
        return self._tasks[task_id]
```

### History Manager

The `history_manager` tracks comparison history:

```python
class HistoryManager:
    HISTORY_FILE = "data/history.json"
    MAX_ENTRIES = 100
    
    def __init__(self):
        self._history = self._load_history()
        
    def _load_history(self):
        """Load comparison history from disk."""
        try:
            if os.path.exists(self.HISTORY_FILE):
                with open(self.HISTORY_FILE, 'r') as f:
                    return json.load(f)
        except Exception as e:
            logger.error(f"Error loading history: {str(e)}")
        return []
        
    def save_history(self, entry):
        """Add a new entry to history and save to disk."""
        self._history.insert(0, entry)
        
        # Limit size
        if len(self._history) > self.MAX_ENTRIES:
            self._history = self._history[:self.MAX_ENTRIES]
            
        # Save to disk
        try:
            os.makedirs(os.path.dirname(self.HISTORY_FILE), exist_ok=True)
            with open(self.HISTORY_FILE, 'w') as f:
                json.dump(self._history, f, indent=4)
        except Exception as e:
            logger.error(f"Error saving history: {str(e)}")
            
    def get_history(self):
        """Get the comparison history."""
        return self._history
        
    def clear_history(self):
        """Clear the comparison history."""
        self._history = []
        
        try:
            if os.path.exists(self.HISTORY_FILE):
                os.remove(self.HISTORY_FILE)
        except Exception as e:
            logger.error(f"Error clearing history: {str(e)}")
```

## Service Instantiation

Services are instantiated once and exported as singletons:

```python
# In utils/logger_service.py
logger_service = LoggerService()

# In utils/file_cache_service.py
file_cache_service = FileCacheService()

# In utils/file_processing_service.py
file_processing_service = FileProcessingService()

# In utils/history_manager.py
history_manager = HistoryManager()
```

## Usage Pattern

Services are imported and used throughout the application:

```python
from utils.logger_service import logger_service
from utils.file_cache_service import file_cache_service
from utils.file_processing_service import file_processing_service
from utils.history_manager import history_manager

# Get a logger
logger = logger_service.get_logger()

# Read a file with caching
content = file_cache_service.read_file(file_path)

# Start async file comparison
task_id = file_processing_service.compare_files_async(
    source_path, 
    target_path, 
    config
)

# Save comparison to history
history_manager.save_history({
    "timestamp": datetime.datetime.now().isoformat(),
    "source_file": os.path.basename(source_path),
    "target_file": os.path.basename(target_path),
    "diff": comparison_result
})
```
```

## Machine Translation

```markdown
# Machine Translation

LocalizerAppMain provides optional machine translation capabilities for automatically translating missing strings from source to target language.

## Overview

The machine translation system:
- Integrates with Google Cloud Translation API
- Automatically detects source and target languages
- Translates missing strings in batch operations
- Provides real-time progress updates
- Handles API errors gracefully

## Configuration

Machine translation has several configuration options:

| Setting | Description | Default |
|---------|-------------|---------|
| mt_enabled | Enable/disable machine translation | false |
| mt_api_key | Google Cloud API key | "" |
| mt_source_lang | Source language code | "en" |
| mt_target_lang | Target language code | "tr" |

These settings are accessed through the Translation settings tab.

## Translation Process

When translation is requested:

1. **Key Analysis**: Missing keys are identified in target file
2. **Batch Processing**: Keys are translated in batches for efficiency
3. **Progress Updates**: UI shows translation progress
4. **Result Integration**: Translations are merged with existing content
5. **File Export**: A new file with translations is created

## Implementation

The translation functionality is implemented in `logic.py`:

```python
def translate_missing_keys(
    source_dict: Dict[str, str],
    target_dict: Dict[str, str],
    source_lang: str,
    target_lang: str,
    api_key: str,
    progress_callback=None
) -> Tuple[Dict[str, str], List[str]]:
    """
    Translate missing keys from source to target language.
    
    Args:
        source_dict: Source translations
        target_dict: Target translations
        source_lang: Source language code
        target_lang: Target language code
        api_key: Google Cloud API key
        progress_callback: Function to call with progress updates
        
    Returns:
        Tuple of updated target dict and list of error messages
    """
    # Make a copy of the target dict to avoid modifying the original
    updated_dict = dict(target_dict)
    
    # Find missing keys (in source but not in target)
    missing_keys = set(source_dict.keys()) - set(target_dict.keys())
    if not missing_keys:
        return updated_dict, []
    
    # Set up Google Cloud Translation client
    try:
        client = translate.Client(api_key)
    except Exception as e:
        return updated_dict, [f"Failed to initialize translation client: {str(e)}"]
    
    # Translate missing keys in batches
    errors = []
    total = len(missing_keys)
    processed = 0
    batch_size = 20  # Adjust based on API limits
    
    for i in range(0, total, batch_size):
        batch_keys = list(missing_keys)[i:i+batch_size]
        batch_values = [source_dict[key] for key in batch_keys]
        
        try:
            # Call the translation API
            results = client.translate(
                batch_values,
                target_language=target_lang,
                source_language=source_lang
            )
            
            # Update the dictionary with translated values
            for key, result in zip(batch_keys, results):
                updated_dict[key] = result['translatedText']
        except Exception as e:
            # Record error but continue with other batches
            error_msg = f"Translation error for batch {i//batch_size}: {str(e)}"
            errors.append(error_msg)
        
        # Update progress
        processed += len(batch_keys)
        if progress_callback:
            progress_callback(processed / total)
    
    return updated_dict, errors
```

## UI Integration

The translation functionality is integrated into the UI via the `translate_missing_keys` method in `App` class:

```python
def translate_missing_keys(self, event):
    """
    Translate missing keys using machine translation.
    """
    if not self.config["mt_enabled"] or not self.config["mt_api_key"]:
        self.show_snackbar("Please enable machine translation and set API key in settings")
        return

    def update_progress(progress):
        self.loading_ring.visible = True
        self.status_label.value = f"Translating... {int(progress * 100)}%"
        self.page.update()

    try:
        # Read and parse files
        with open(self.source_file_path, 'r', encoding='utf-8') as source_file:
            source_content = source_file.read()
        with open(self.target_file_path, 'r', encoding='utf-8') as target_file:
            target_content = target_file.read()
            
        ext_source = Path(self.source_file_path).suffix.lower()
        ext_target = Path(self.target_file_path).suffix.lower()
        
        source_dict = logic.parse_content_by_ext(source_content, ext_source)
        target_dict = logic.parse_content_by_ext(target_content, ext_target)
        
        # Perform translation
        self.loading_ring.visible = True
        self.status_label.value = "Translating missing keys..."
        self.page.update()
        
        updated_dict, errors = logic.translate_missing_keys(
            source_dict,
            target_dict,
            self.config["mt_source_lang"],
            self.config["mt_target_lang"],
            self.config["mt_api_key"],
            update_progress
        )
        
        # Handle any errors
        if errors:
            error_msg = "\n".join(errors[:5])
            if len(errors) > 5:
                error_msg += f"\n...and {len(errors) - 5} more errors"
            self.show_snackbar(f"Some translations failed: {error_msg}")
        
        # Prompt for save location
        save_dialog = FilePicker(
            on_result=lambda result: self.save_translated_file(result, updated_dict)
        )
        self.page.overlay.append(save_dialog)
        save_dialog.save_file(file_name=f"new_target{ext_target}")
    except Exception as e:
        self.show_snackbar(f"Translation error: {str(e)}")
    finally:
        self.loading_ring.visible = False
        self.page.update()
```

## Supported Languages

The application supports translation between 100+ languages through Google Cloud Translation API:

- Language codes are defined in constants.py
- Language selection is available in settings
- Both source and target languages can be selected independently

## API Key Management

For security:
- API keys are stored locally in the configuration file
- Keys are displayed as password fields with reveal option
- Users can test their API keys before using translation
```

## Error Handling

```markdown
# Error Handling

LocalizerAppMain implements a robust error handling system to provide meaningful feedback and maintain application stability.

## Error Types

The application handles several categories of errors:

| Error Type | Source | Handling |
|------------|--------|----------|
| File errors | File loading/saving | User notification |
| Parsing errors | Format parsing | Detailed feedback with line numbers |
| Comparison errors | Translation comparison | Error state in UI |
| Translation errors | Machine translation | Graceful fallback |
| Configuration errors | Settings management | Defaults with warnings |
| Network errors | API calls | Offline mode |

## Custom Exceptions

The application defines custom exceptions for specific error scenarios:

```python
# core/errors.py

class LocalizerError(Exception):
    """Base exception for all localizer errors."""
    pass

class FileFormatError(LocalizerError):
    """Raised when a file format is not supported or detected."""
    pass

class ParserError(LocalizerError):
    """Base class for parser-related errors."""
    pass

class JSONParsingError(ParserError):
    """Raised when JSON parsing fails."""
    pass

class XMLParsingError(ParserError):
    """Raised when XML parsing fails."""
    pass

class CSVParsingError(ParserError):
    """Raised when CSV parsing fails."""
    pass

class YAMLParsingError(ParserError):
    """Raised when YAML parsing fails."""
    pass

class TranslationError(LocalizerError):
    """Raised when machine translation fails."""
    pass

class ConfigError(LocalizerError):
    """Raised when configuration is invalid."""
    pass
```

## Error Feedback

Errors are communicated to users through:

1. **Snackbar Notifications**: Temporary pop-up messages for non-critical errors
2. **Status Updates**: Error status in the application status bar
3. **Dialog Boxes**: Modal dialogs for critical errors requiring attention
4. **Visual Indicators**: Color-coded interfaces showing error states
5. **Log Messages**: Detailed logging for troubleshooting

## Implementation

### Error Handling in File Parsing

# Error Handling

```markdown
# Error Handling

LocalizerAppMain implements a robust error handling system to provide meaningful feedback and maintain application stability.

## Error Types

The application handles several categories of errors:

| Error Type | Source | Handling |
|------------|--------|----------|
| File errors | File loading/saving | User notification |
| Parsing errors | Format parsing | Detailed feedback with line numbers |
| Comparison errors | Translation comparison | Error state in UI |
| Translation errors | Machine translation | Graceful fallback |
| Configuration errors | Settings management | Defaults with warnings |
| Network errors | API calls | Offline mode |

## Custom Exceptions

The application defines custom exceptions for specific error scenarios:

```python
# core/errors.py

class ParsingError(Exception):
    """Base class for parsing related errors."""
    pass

class FileParsingError(ParsingError):
    """Base exception for file parsing issues."""
    pass

class CSVParsingError(FileParsingError):
    """Raised when CSV parsing fails."""
    pass

class XMLParsingError(FileParsingError):
    """Raised when XML parsing fails."""
    pass

class JSONParsingError(FileParsingError):
    """Raised when JSON parsing fails."""
    pass

class YAMLParsingError(FileParsingError):
    """Raised when YAML parsing fails."""
    pass

class UnknownFormatError(FileParsingError):
    """Raised when file format is not recognized."""
    pass
```

## Error Feedback

Errors are communicated to users through:

1. **Snackbar Notifications**: Temporary pop-up messages for non-critical errors
2. **Status Updates**: Error status in the application status bar
3. **Dialog Boxes**: Modal dialogs for critical errors requiring attention
4. **Visual Indicators**: Color-coded interfaces showing error states
5. **Log Messages**: Detailed logging for troubleshooting

## Implementation

### Error Handling in File Parsing

```python
def parse_content_by_ext(content: str, extension: str) -> Dict[str, str]:
    """Parse content based on file extension with error handling."""
    try:
        if extension.lower() in ('.json'):
            parser = JSONParser()
        elif extension.lower() in ('.xml', '.resx'):
            parser = XMLParser()
        elif extension.lower() in ('.csv'):
            parser = CSVParser()
        # ... other formats
        else:
            raise UnknownFormatError(f"Unsupported file extension: {extension}")
            
        return parser.parse(content)
    except JSONParsingError as e:
        logger.error(f"JSON parsing error: {str(e)}")
        raise FileParsingError(f"JSON parsing error: {str(e)}")
    except XMLParsingError as e:
        logger.error(f"XML parsing error: {str(e)}")
        raise FileParsingError(f"XML parsing error: {str(e)}")
    except Exception as e:
        logger.error(f"Unexpected parsing error: {str(e)}")
        raise FileParsingError(f"Error parsing file: {str(e)}")
```

### UI Error Handling

```python
def show_error_dialog(self, title, message):
    """Show error dialog with detailed information."""
    dialog = ft.AlertDialog(
        title=ft.Text(title, color=self.COLORS["text"]["error"]),
        content=ft.Text(message),
        actions=[
            ft.TextButton("OK", on_click=lambda e: self.close_dialog())
        ],
    )
    self.page.dialog = dialog
    self.page.update()
    
def show_snackbar(self, message):
    """Show temporary notification with error or success message."""
    self.page.snack_bar = ft.SnackBar(
        content=ft.Text(message),
        action="Dismiss",
    )
    self.page.snack_bar.open = True
    self.page.update()
```

### Graceful Degradation

The application implements graceful degradation strategies:

1. **Default Values**: If configuration loading fails, use defaults
2. **Format Fallbacks**: If primary parser fails, try alternative parsing approaches
3. **Error Recovery**: After an error, allow users to continue working
4. **State Preservation**: Save work before potentially risky operations
5. **Error Boundaries**: Contain errors to specific components
```

## Installation and Setup

```markdown
# Installation and Setup

This guide provides step-by-step instructions for installing and running LocalizerAppMain on different platforms.

## Prerequisites

- Python 3.8 or higher
- pip (Python package installer)
- Git (optional, for cloning the repository)

## Installation Methods

### Method 1: Direct Download & Installation

1. **Download the repository**
   - Visit [GitHub Repository](https://github.com/KhazP/LocalizerAppMain)
   - Click the green "Code" button and select "Download ZIP"
   - Extract the ZIP file to your desired location

2. **Set up a virtual environment** (recommended)
   ```bash
   # Navigate to the extracted directory
   cd LocalizerAppMain
   
   # Create a virtual environment
   python -m venv venv
   
   # Activate the virtual environment
   # On Windows:
   venv\Scripts\activate
   # On macOS/Linux:
   source venv/bin/activate
   ```

3. **Install dependencies**
   ```bash
   pip install -r requirements.txt
   ```

### Method 2: Using Git

1. **Clone the repository**
   ```bash
   git clone https://github.com/KhazP/LocalizerAppMain.git
   cd LocalizerAppMain
   ```

2. **Set up a virtual environment**
   ```bash
   python -m venv venv
   
   # Activate the virtual environment
   # On Windows:
   venv\Scripts\activate
   # On macOS/Linux:
   source venv/bin/activate
   ```

3. **Install dependencies**
   ```bash
   pip install -r requirements.txt
   ```

### Method 3: Using Conda (Alternative)

1. **Clone or download the repository**

2. **Create a conda environment**
   ```bash
   conda create -n localizer python=3.10
   conda activate localizer
   ```

3. **Install dependencies**
   ```bash
   pip install -r requirements.txt
   ```

## Running the Application

```bash
# Make sure your virtual environment is activated
python -m GUI.flet_gui
```

## First-Time Setup

The first time you run the application:

1. The application will create a default configuration file
2. You'll be shown an onboarding tutorial
3. Default settings will be applied

## Optional Dependencies

For specific file formats or features:

- **PyYAML**: Required for YAML file support
  ```bash
  pip install pyyaml
  ```

- **python-magic**: For improved file format detection
  ```bash
  # On Windows:
  pip install python-magic-bin
  
  # On macOS:
  pip install python-magic
  
  # On Linux:
  apt-get install libmagic1  # or equivalent for your distribution
  pip install python-magic
  ```

- **Google Cloud Translation**: For machine translation features
  ```bash
  pip install google-cloud-translate==2.0.1
  ```

## Troubleshooting

### Common Issues

1. **Missing module errors**
   - Ensure all dependencies are installed: `pip install -r requirements.txt`
   - Check that your virtual environment is activated

2. **File format issues**
   - Ensure your localization files use UTF-8 encoding
   - Check if the format is supported (see documentation)

3. **Display issues**
   - Flet requires a proper display environment
   - On some Linux systems without a desktop environment, you may need additional packages

### Getting Help

If you encounter issues:
1. Check the [GitHub Issues](https://github.com/KhazP/LocalizerAppMain/issues) for known problems
2. Search the Wiki for documentation
3. Open a new issue with detailed information about the problem
```

## Contributing Guidelines

```markdown
# Contributing Guidelines

Thank you for your interest in contributing to LocalizerAppMain! This guide explains how to contribute to the project effectively.

## Ways to Contribute

1. **Report bugs**: Create detailed issues for problems you encounter
2. **Suggest features**: Share ideas for improvements and new capabilities
3. **Improve documentation**: Fix errors or add missing information
4. **Write code**: Implement new features or fix bugs
5. **Review code**: Help maintain quality through code reviews

## Development Setup

Follow these steps to set up your development environment:

1. **Fork the repository** on GitHub
2. **Clone your fork**
   ```bash
   git clone https://github.com/YOUR_USERNAME/LocalizerAppMain.git
   cd LocalizerAppMain
   ```

3. **Set up a virtual environment**
   ```bash
   python -m venv venv
   
   # Activate the virtual environment
   # On Windows:
   venv\Scripts\activate
   # On macOS/Linux:
   source venv/bin/activate
   ```

4. **Install dependencies including development tools**
   ```bash
   pip install -r requirements.txt
   pip install -r requirements-dev.txt
   ```

5. **Set up pre-commit hooks**
   ```bash
   pre-commit install
   ```

## Development Workflow

1. **Create a new branch** for your feature or bugfix
   ```bash
   git checkout -b feature/your-feature-name
   # or
   git checkout -b fix/issue-number-description
   ```

2. **Make changes** to implement your feature or fix the bug

3. **Write tests** to verify your changes
   ```bash
   pytest tests/
   ```

4. **Run linting** to ensure code quality
   ```bash
   flake8
   black .
   ```

5. **Update documentation** if necessary

6. **Commit your changes** with clear messages
   ```bash
   git commit -m "Add feature: description of your changes"
   ```

7. **Push your branch** to your fork
   ```bash
   git push origin feature/your-feature-name
   ```

8. **Create a pull request** from your fork to the main repository

## Pull Request Guidelines

Please follow these guidelines when submitting a pull request:

1. **Reference issues**: Link to any related issues in the PR description
2. **Describe changes**: Clearly explain what your changes do
3. **Include tests**: Add tests for new features or bug fixes
4. **Update documentation**: Update relevant documentation
5. **Follow code style**: Ensure your code follows project conventions
6. **Keep PRs focused**: Submit separate PRs for unrelated changes

## Commit Message Format

Use clear and descriptive commit messages:

```
<type>: <subject>

<body>

<footer>
```

Where `<type>` is one of:
- **feat**: A new feature
- **fix**: A bug fix
- **docs**: Documentation changes
- **style**: Code style changes (formatting, etc)
- **refactor**: Code refactoring
- **test**: Adding or updating tests
- **chore**: Maintenance tasks

Examples:
```
feat: add support for XLIFF format

Add parser for XLIFF format including bidirectional conversion

Closes #42
```

```
fix: correct CSV parser line number tracking

Fix issue where CSV line numbers were off by one in error reporting

Fixes #56
```

## Code Style

This project follows these style guidelines:

1. **PEP 8**: Follow Python style guide
2. **Type hints**: Use type annotations where applicable
3. **Docstrings**: Include docstrings for all functions, classes, and modules
4. **Imports**: Organize imports alphabetically within sections

## Testing

All contributions should include appropriate tests:

1. **Unit tests**: For individual components and functions
2. **Integration tests**: For interactions between components
3. **UI tests**: For user interface components

Run tests with:
```bash
pytest
```

## Review Process

Pull requests are reviewed by maintainers who will:

1. Verify code quality and test coverage
2. Provide feedback on implementation
3. Request changes if necessary
4. Approve and merge when ready

## License

By contributing, you agree that your code will be licensed under the project's license.
```

## FAQ

```markdown
# Frequently Asked Questions (FAQ)

## General Questions

### What is LocalizerAppMain?
LocalizerAppMain is an open-source tool for comparing and analyzing localization files across different formats. It helps translation teams identify missing, extra, or modified strings between source and target language files.

### What file formats are supported?
The application supports multiple formats including:
- JSON (.json)
- XML (.xml, .resx)
- CSV (.csv)
- YAML (.yaml, .yml)
- Properties (.properties)
- Lang Files (.lang)
- XLIFF (.xlf, .xliff)

### Is LocalizerAppMain free to use?
Yes, LocalizerAppMain is completely free and open-source under the MIT license.

### Does it work on my operating system?
Yes, LocalizerAppMain works on Windows, macOS, and Linux since it's built with Python and Flet.

## Usage Questions

### How do I compare two files?
1. Click "Browse" to select your source file (original language)
2. Click "Browse" to select your target file (translated language)
3. Click "Compare" to analyze differences
4. View the results showing added, missing, and modified strings

### How do I interpret the comparison results?
- `+` (green) indicates strings present in the source but missing from the target
- `-` (red) indicates strings present in the target but missing from the source
- No prefix indicates strings present in both files with identical values
- `~` indicates strings present in both files but with different values

### Can I compare files in different formats?
Yes, you can compare files in different formats (e.g., JSON to XML). The application will extract the key-value pairs regardless of format.

### What are namespaces in the context of this application?
Namespaces refer to the hierarchical organization of translation keys. For example, in the key `common.buttons.save`, the namespace would be `common.buttons`.

### How do I use the machine translation feature?
1. Go to Settings > Translation
2. Enable machine translation
3. Enter your Google Cloud API key
4. Select source and target languages
5. When comparing files, use the "Translate Missing" button

## Technical Questions

### Why am I seeing parsing errors?
Parsing errors typically occur when:
- The file format doesn't match its extension
- The file is corrupted or malformatted
- The file uses an unsupported encoding

### How do I report bugs or request features?
Please report bugs and feature requests on our [GitHub Issues page](https://github.com/KhazP/LocalizerAppMain/issues).

### How can I contribute to the project?
See our [Contributing Guidelines](CONTRIBUTING.md) for information on how to contribute code, documentation, or translations.

### What are the system requirements?
- Python 3.8 or higher
- 4GB RAM (recommended)
- 100MB disk space for the application
- Additional space for localization files

### Can I use this in my CI/CD pipeline?
Yes, the core comparison logic can be used in CI/CD pipelines. We're working on a dedicated CLI interface to make this easier.

## Troubleshooting

### The application crashes when opening large files
Try enabling the "Optimize for large files" option in Settings > Performance which uses lazy loading.

### I'm seeing incorrect line numbers in the results
Line numbers depend on the file format and parsing method. For some formats like JSON, line numbers are approximations.

### Machine translation isn't working
Ensure your API key is valid and you have quota available in your Google Cloud account. Check that you've selected the correct source and target languages.

### Missing strings aren't being shown
Check if you have filter settings enabled. Try disabling the "Ignore patterns" option in Settings > Comparison.

### The UI looks different from the screenshots
Your theme setting might be different. Try switching between light, dark, and system themes in Settings > General.
```

## Roadmap and Future Development

```markdown
# Roadmap and Future Development

This page outlines the planned features and improvements for future releases of LocalizerAppMain.

## Short-Term Goals (Next 3 Months)

### Enhanced Format Support
- [ ] Add support for Android String Resources XML format
- [ ] Add support for iOS Strings format
- [ ] Improve XLIFF support with namespace preservation

### Performance Improvements
- [ ] Optimize memory usage for multi-megabyte files

### UI Enhancements
- [ ] Add split-view comparison mode
- [ ] Implement in-place editing for translations
- [ ] Add context menu for common operations
- [ ] Improve visual diff highlighting
- [ ] Line number tracking

### Testing and Stability
- [ ] Add end-to-end testing with real files
- [ ] Improve error reporting and diagnostics

## Medium-Term Goals (Next 6-9 Months)

### Feature Additions
- [ ] Implement batch operations for multiple files
- [ ] Add support for directory comparison
- [ ] Add version history tracking for files

### Localization Workflow
- [ ] Add comment support for translators
- [ ] Implement glossary and terminology management
- [ ] Add placeholder validation and consistency checking
- [ ] Create workflow status tracking for translations

## Long-Term Vision (1+ Years)

### Advanced Features
- [ ] Implement AI-powered translation suggestions
- [ ] Add visual context capture for translators
- [ ] Create translation memory system
- [ ] Implement real-time collaboration

### Integration Ecosystem
- [ ] Develop integrations with version control systems
- [ ] Add support for translation management systems
- [ ] Implement CI/CD pipeline integration

## Completed Features

### Version 1.0
- [x] Basic file comparison for JSON, XML, CSV
- [x] Visual display of differences
- [x] Theme support (dark/light)
- [x] Basic settings management

### Version 1.1
- [x] Added YAML support
- [x] Improved error handling
- [x] Added statistics panel

### Version 1.2
- [x] Added machine translation integration
- [x] Improved accessibility features
- [x] Added file format detection
- [x] Created comparison history

## Contributing to the Roadmap

I welcome community input on our roadmap priorities. If you have suggestions or would like to contribute to implementing any of these features:

1. Join the discussion in the [GitHub Issues](https://github.com/KhazP/LocalizerAppMain/issues)
2. Tag feature requests with the "enhancement" label
3. Vote on existing feature requests to help prioritize
4. Consider implementing features yourself and submitting a pull request

This roadmap is subject to change based on community feedback and emerging priorities.
```
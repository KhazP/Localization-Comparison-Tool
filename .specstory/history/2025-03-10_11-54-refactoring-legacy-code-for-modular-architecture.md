<!-- Generated by SpecStory -->

# Refactoring legacy code for modular architecture (2025-03-10 14:54:55)

_**User**_

@workspace  I recently refactored my codebase to implement modular components to improve maintainability. However, the main file (flet_gui.py) still contains legacy code that duplicates the functionality now provided by these modular components. Could you analyze the entire codebase and help me:

Identify which modular components are correctly implemented and actively used,
Pinpoint any components that are either redundant or not functioning as intended, and
Suggest strategies to clean up or fully remove the duplicate legacy code from flet_gui.py?
I'm looking for detailed insights on component dependencies and integration to achieve a cleaner, more modular architecture. 

---

_**Assistant**_

# Component Architecture Analysis: Localization Comparison Tool

After analyzing your codebase, I've identified where you've successfully implemented modular components and where legacy code is duplicating functionality. Here's a comprehensive breakdown:

## Properly Implemented Components

1. **SettingsDialogComponent** - Well integrated and functioning correctly
   - Properly encapsulates settings UI and logic
   - App class correctly delegates settings functionality to this component
   - Clean separation of concerns with proper event handling

2. **HistoryDialogComponent** - Well integrated
   - Good encapsulation of history viewing functionality
   - Properly handles its own UI state and actions

3. **OnboardingTutorial** - Properly implemented
   - Correctly initialized and called from the main app
   - Effectively handles tutorial presentation

## Partially Implemented Components with Redundancies

1. **FileInputComponent**
   - **Issue**: App class duplicates file handling logic
   - While you import and instantiate this component, the `App` class still maintains its own file pickers, labels, and methods like `handle_file_picked`, `open_source_picker`, etc.
   - The component is initialized but its functionality is shadowed by methods in the main class

2. **ResultsViewComponent** 
   - **Issue**: Major redundancies in UI rendering logic
   - Methods like `build_results_table`, `filter_results`, and `create_result_row` in the App class duplicate functionality that should be in ResultsViewComponent
   - You're initializing the component but still handling most of the display logic in the App class

3. **StatsPanelComponent**
   - **Issue**: Not fully utilized
   - You're importing it and creating an instance, but the `App` class still creates its own statistics panel UI
   - The `update_statistics` method in App should be delegated to this component

## Refactoring Recommendations

### 1. FileInputComponent Refactoring

```python
# Current redundant code in App class:
self.source_picker = FilePicker(on_result=lambda e: self.handle_file_picked(e, self.source_label, self.source_icon, "source"))
self.target_picker = FilePicker(on_result=lambda e: self.handle_file_picked(e, self.target_label, self.target_icon, "target"))

# Remove these and use the component's methods instead:
# file_input.py already has methods like:
def handle_file_picked(self, e, label, icon, clear_btn, file_type)
def open_source_picker(self, _)
def open_target_picker(self, _)
```

Delegate file operations to the component:
```python
# Replace direct file operations with:
def open_source_picker(self, e):
    self.file_input.open_source_picker(e)

def handle_source_selected(self, file_path):
    self.source_file_path = file_path
    # Let FileInputComponent handle UI updates
```

### 2. ResultsViewComponent Refactoring

Move the results display logic from App class to the component:

```python
# Instead of:
def build_results_table(self, comparison_result):
    # ... complex table building logic ...
    
# Call the component's method:
def display_comparison_results(self, comparison_result):
    self.results_view.build_results_table(
        comparison_result, 
        self.source_line_numbers, 
        self.target_line_numbers, 
        self.config
    )
```

### 3. StatsPanelComponent Integration

```python
# Replace:
self.stats_panel = Card(...)  # Your custom implementation

# With:
self.stats_panel = self.stats_panel_component.panel

# And replace:
def update_statistics(self, total_keys, missing_keys, obsolete_keys):
    # ... logic ...
    
# With:
def update_statistics(self, total_keys, missing_keys, obsolete_keys):
    self.stats_panel_component.update_stats(total_keys, missing_keys, obsolete_keys)
```

### 4. Theme Management Extraction

Consider creating a ThemeManager component to handle the complex color system:

```python
# Extract from App class:
def update_theme_colors(self):
    # ... complex theme logic ...

# Create a new ThemeManager component that components can subscribe to
```

## Implementation Strategy

1. **Focus on one component at a time** - Start with the most isolated component (like FileInputComponent)

2. **Follow this process for each component**:
   - Identify all methods in `App` that handle functionality related to the component
   - Ensure the component itself has corresponding methods
   - Update the component's methods if needed
   - Replace direct calls in App with calls to component methods
   - Remove redundant UI elements and methods from the App class

3. **Address shared state carefully** - Make sure components have access to needed state (config, file paths, etc.)

4. **Update theme integration** - Ensure all components receive and react to theme changes through a consistent mechanism

This approach will help you achieve a cleaner architecture with proper separation of concerns while minimizing the risk of breaking functionality during the refactoring process.

---

_**User**_

@workspace I've implemented these, check the codebase again for issues please.

Fixed issues:

1. FileInputComponent

Issue: App class duplicates file handling logic

2. ResultsViewComponent

Issue: Major redundancies in UI rendering logic

3. StatsPanelComponent

Issue: Not fully utilized

---

_**Assistant**_

# Codebase Architecture Review: Modular Component Implementation

After examining your updated implementation, I can see you've made progress on modularizing the codebase. Here's an analysis of remaining issues and opportunities for further improvement:

## 1. Component Integration Status

### Well-Integrated Components

- **SettingsDialogComponent** - Properly initialized and delegated:
  ```python
  self.settings_dialog_component = SettingsDialogComponent(page, self, self.config, self.COLORS)
  self.settings_dialog = self.settings_dialog_component.dialog
  ```

- **HistoryDialogComponent** - Properly initialized and delegated:
  ```python 
  self.history_dialog = HistoryDialogComponent(page, self)
  page.overlay.append(self.history_dialog.dialog)
  ```

### Components with Integration Issues

1. **FileInputComponent** - Partial delegation remains problematic:
   ```python
   # You've kept these direct references which creates tight coupling
   self.source_file_container = self.file_input.source_file_container
   self.target_file_container = self.file_input.target_file_container
   self.source_label = self.file_input.source_label
   self.source_icon = self.file_input.source_icon
   ```

2. **ResultsViewComponent** - Display logic duplication:
   ```python
   # You've still kept this code in compare_files_gui
   self.output_text.value = comparison_result
   # While also delegating to the component
   self.results_view.build_results_table(comparison_result)
   ```

3. **StatsPanelComponent** - Integration looks good, but there's still duplicate declaration:
   ```python
   # This is duplicated - declared first at line ~258
   self.stats_panel_component = StatsPanelComponent(page, self, self.COLORS)
   # Then referenced again later
   ```

## 2. Major Redundancy Issues

### A. Directory Comparison Logic

The `compare_directories()` method (lines 1389-1493) contains significant duplicated functionality that should be moved to a component or service:

```python
def compare_directories(self):
    """Compare all matching files in source and target directories with improved error handling"""
    self.loading_ring.visible = True
    # ... ~100 lines of code containing UI logic and business logic 
```

You have an async version `compare_directories_async` that uses `file_processing_service` - the older synchronous method should be removed.

### B. Direct UI Element Manipulation

In `update_theme_colors()`, you still manually update colors of UI elements from components:

```python
# Direct manipulation of component elements
self.source_icon.color = self.COLORS["text"]["secondary"]
self.target_icon.color = self.COLORS["text"]["secondary"]
self.source_label.color = self.COLORS["text"]["secondary"]
self.target_label.color = self.COLORS["text"]["secondary"]
```

### C. Duplicate File Comparison Logic

The `compare_file()` method (lines 1525-1627) duplicates functionality that should be in a service or component:

```python
def compare_file(self):
    """Compare the selected file with improved error handling and UI feedback"""
    # ... ~100 lines of direct file handling and UI updates
```

## 3. Recommended Cleanup Strategy

1. **Stop exposing component internals**:
   - Don't extract internal UI elements from components (`self.source_label = self.file_input.source_label`)
   - Instead, add methods to components to handle operations on those elements

2. **Create method pairs for component delegation**:
   ```python
   # In App class
   def update_file_preview(self, file_path, field_type):
       self.file_input.update_file_preview(file_path, field_type)
   ```

3. **Move all file-related operations to FileInputComponent**:
   - Directory handling belongs with other file operations
   - Create a unified file interface (`open_file`, `open_directory`)

4. **Create a separate DirectoryComparisonComponent**:
   - Move directory comparison UI and logic to its own component
   - Keep `App` class focused on coordination rather than implementation

5. **Create a ThemeManager component**:
   - Move the complicated theme logic out of the `App` class
   - Make components register with the theme manager

6. **Clean up duplicate methods**:
   - Delete `compare_directories()` - use `compare_directories_async` exclusively
   - Delete `compare_file()` - move logic to a service

## 4. Specific Code to Remove or Refactor

```python
# Remove: Duplicate initialization (mentioned above)
# Around line 372
self.results_view = ResultsViewComponent(page, self, self.COLORS)
self.output_text = self.results_view.output_text
self.summary_text = self.results_view.summary_text

# Remove: Legacy compare_directories method (lines 1389-1493)
def compare_directories(self):
    # Use compare_directories_async exclusively

# Remove: Direct UI element manipulation in toggle_expand_all (lines 1166-1177)
def toggle_expand_all(self, e):
    # Should delegate to results_view.toggle_expand_all
```

By cleaning up these issues, you'll achieve a more maintainable architecture with proper separation of concerns between your components and the main application class.

---

_**User**_

@workspace create prompts for copilot edits agent mode for this issue:

Create a ThemeManager component:

Move the complicated theme logic out of the App class
Make components register with the theme manager

---

_**Assistant**_

# Creating a ThemeManager Component: Implementation Guide

Currently, your application's theme management is handled directly in the `App` class, which creates tight coupling between the UI logic and theme management. Let's create a `ThemeManager` component that will centralize theme management and improve the modularity of your application.

## Step 1: Create a New ThemeManager Class

Create a new file at `components/theme_manager.py`:

```python
import flet as ft
import logging
from typing import Dict, Any, Callable, List
from core.themes import THEMES
from core.config import ConfigManager

try:
    import darkdetect
    HAS_DARKDETECT = True
except ImportError:
    HAS_DARKDETECT = False
    logging.warning("darkdetect package not found. System theme detection will fall back to 'dark'.")

class ThemeManager:
    """Manages theme colors and notifies registered components of theme changes"""
    
    def __init__(self, page: ft.Page, config: Dict[str, Any]):
        self.page = page
        self.config = config
        self.current_theme = config.get("theme", "system")
        self.THEMES = THEMES
        self._cached_colors = {}
        self.COLORS = self._get_initial_colors()
        self._registered_components = []
        
    def _get_initial_colors(self) -> Dict:
        """Get the initial colors based on config theme setting"""
        theme_key = self.config.get("theme", "system")
        
        if theme_key == "system":
            if HAS_DARKDETECT:
                system_theme = "dark" if darkdetect.isDark() else "light"
            else:
                system_theme = "dark"
            colors = self.THEMES[system_theme]
        else:
            colors = self.THEMES[theme_key]
        
        # Cache the colors
        self._cached_colors[theme_key] = colors
        return colors
    
    def register_component(self, component):
        """Register a component to receive theme updates
        
        Components must implement update_colors(colors) method
        """
        if hasattr(component, 'update_colors') and callable(component.update_colors):
            if component not in self._registered_components:
                self._registered_components.append(component)
                # Update component with current theme immediately
                component.update_colors(self.COLORS)
        else:
            logging.warning(f"Component {type(component).__name__} does not implement update_colors method")
    
    def unregister_component(self, component):
        """Remove a component from theme updates"""
        if component in self._registered_components:
            self._registered_components.remove(component)
    
    def apply_theme(self, theme_key: str):
        """Change the current theme and notify all registered components"""
        self.current_theme = theme_key
        
        # Update page theme mode
        if theme_key == "system":
            if HAS_DARKDETECT:
                system_theme = "dark" if darkdetect.isDark() else "light"
            else:
                system_theme = "dark"
            self.page.theme_mode = ft.ThemeMode.SYSTEM
            self.COLORS = self.THEMES[system_theme]
        elif theme_key in ["dark", "amoled"]:
            self.page.theme_mode = ft.ThemeMode.DARK
            self.COLORS = self.THEMES[theme_key]
        else:
            self.page.theme_mode = ft.ThemeMode.LIGHT
            self.COLORS = self.THEMES[theme_key]
            
        # Handle custom theme overrides
        custom_theme = self.config.get("custom_theme", {})
        if isinstance(custom_theme, dict):
            if "main" in custom_theme:
                self.COLORS["bg"]["primary"] = custom_theme["main"]
            if "accent" in custom_theme:
                self.COLORS["bg"]["accent"] = custom_theme["accent"]
            if "background" in custom_theme:
                self.COLORS["bg"]["secondary"] = custom_theme["background"]
            if "text" in custom_theme:
                self.COLORS["text"]["primary"] = custom_theme["text"]
        
        # Cache the colors
        self._cached_colors[theme_key] = self.COLORS
        
        # Update config
        self.config["theme"] = theme_key
        ConfigManager.save(self.config)
        
        # Update page background color
        self.page.bgcolor = self.COLORS["bg"]["primary"]
        
        # Notify all registered components
        for component in self._registered_components:
            component.update_colors(self.COLORS)
        
        # Update page
        self.page.update()
        
        logging.info(f"Theme updated to '{theme_key}'")
        
    def get_colors(self) -> Dict:
        """Get the current theme colors"""
        return self.COLORS
```

## Step 2: Modify the App Class

Update the `App` class in `flet_gui.py` to use the ThemeManager:

```python
# Add to imports at the top
from components.theme_manager import ThemeManager

class App:
    def __init__(self, page: ft.Page):
        # Initialize other parts of the app...
        
        # Create theme manager and register it early
        self.theme_manager = ThemeManager(page, self.config)
        
        # Rest of initialization...
        
        # Register components with the theme manager
        self.theme_manager.register_component(self.file_input)
        self.theme_manager.register_component(self.results_view)
        self.theme_manager.register_component(self.stats_panel_component)
        self.theme_manager.register_component(self.settings_dialog_component)
        
        # Register other components as needed
        if hasattr(self, 'history_dialog'):
            self.theme_manager.register_component(self.history_dialog)
        if hasattr(self, 'tutorial'):
            self.theme_manager.register_component(self.tutorial)
        
        # Apply initial theme
        self.theme_manager.apply_theme(self.config.get("theme", "system"))
    
    # Replace update_theme_colors with a delegate method
    def update_theme_colors(self):
        """Update the colors in the UI using the current theme settings."""
        self.theme_manager.apply_theme(self.config.get("theme", "system"))
        
    # Update handle_theme_change to use theme_manager
    def handle_theme_change(self, e):
        """Handle theme mode changes"""
        theme = e.control.value
        self.theme_manager.apply_theme(theme)
        
    # Provide a getter for access to colors
    @property
    def COLORS(self):
        return self.theme_manager.COLORS
```

## Step 3: Update Component Initialization

Modify component initialization to get colors from the ThemeManager:

```python
# For example, in the __init__ method of the App class:
self.file_input = FileInputComponent(page, self)
self.results_view = ResultsViewComponent(page, self, self.theme_manager.get_colors())
self.stats_panel_component = StatsPanelComponent(page, self, self.theme_manager.get_colors())
```

## Step 4: Testing

Create tests for the ThemeManager in `tests/test_theme_manager.py`:

```python
import pytest
from unittest.mock import Mock, patch
from components.theme_manager import ThemeManager
from core.themes import THEMES

@pytest.fixture
def mock_page():
    return Mock()

@pytest.fixture
def mock_config():
    return {
        "theme": "dark",
        "custom_theme": {}
    }

@pytest.fixture
def theme_manager(mock_page, mock_config):
    return ThemeManager(mock_page, mock_config)

def test_init_with_dark_theme(mock_page, mock_config):
    theme_manager = ThemeManager(mock_page, mock_config)
    assert theme_manager.current_theme == "dark"
    assert theme_manager.COLORS == THEMES["dark"]

def test_register_component(theme_manager):
    component = Mock()
    theme_manager.register_component(component)
    assert component in theme_manager._registered_components
    component.update_colors.assert_called_once_with(theme_manager.COLORS)

def test_apply_theme(theme_manager, mock_config):
    # Register mock components
    component1 = Mock()
    component2 = Mock()
    theme_manager.register_component(component1)
    theme_manager.register_component(component2)
    
    # Apply a different theme
    theme_manager.apply_theme("light")
    
    # Check that theme was updated
    assert theme_manager.current_theme == "light"
    assert theme_manager.COLORS == THEMES["light"]
    
    # Check that components were updated
    component1.update_colors.assert_called_with(theme_manager.COLORS)
    component2.update_colors.assert_called_with(theme_manager.COLORS)
```

## Benefits of This Approach

1. **Separation of Concerns**: Theme logic is now separate from the App class
2. **Reduced Coupling**: Components interact with ThemeManager instead of App
3. **Simplified Registration**: Components can be automatically registered
4. **Extensibility**: New theme features can be added to the ThemeManager without changing App
5. **Better Testability**: Theme logic can be tested independently

This implementation maintains all your existing functionality while providing a cleaner architecture and better modularity.

---

_**User**_

Ok I implemented those with copilot edits agent mode. Now lets improve themes. Lits make every component, UI elements, etc become white with light mode, full black with amoled mode, and dark with dark mode.

Create a prompt for this.

---

_**Assistant**_

# Prompt for GitHub Copilot: Theme Consistency Improvement

```
I need to ensure consistent theme application across all UI components. Our app uses a ThemeManager that notifies registered components of theme changes, but there may be inconsistencies in implementation.

Please help me:

1. Analyze all components to ensure they properly implement the update_colors(colors) method
2. Check theme definitions in core/themes.py to ensure:
   - Light theme uses predominantly white backgrounds
   - Dark theme uses dark gray backgrounds
   - AMOLED theme uses true black (#000000) backgrounds
3. Look for any hardcoded colors that should be replaced with theme references
4. Ensure proper contrast ratios for text/background combinations in all themes
5. Add any missing color definitions needed by components

Focus on these component files:
- components/file_input.py
- components/results_view.py
- components/stats_panel.py
- components/history_dialog.py
- components/settings_dialog.py
- components/onboarding.py

For each component, suggest changes to update_colors() methods to ensure consistent appearance across theme changes.
```

This prompt should guide GitHub Copilot to help you make your themes more consistent, ensuring that light mode uses white elements, dark mode uses dark elements, and AMOLED mode properly uses true black throughout the UI.

---

_**User**_

When I change themes, some UI elements don't change color, but after restarting the app they change, and the same happens vice versa.

---

_**Assistant**_

# Theme Consistency Implementation Guide

Your issue stems from inconsistent theme handling across UI elements. Some components update correctly on theme change while others wait for a restart. Here's how to fix this:

## Key Issues

1. **Incomplete Direct UI Element Updates**: Many UI elements in the App class aren't updated during theme changes
2. **Inconsistent Theme Definitions**: Some themes are missing key color definitions
3. **Dynamic UI Elements**: Elements created after initialization aren't getting theme updates

## Solution Implementation

### 1. Create an App-Level Theme Updater

First, add a comprehensive method in your App class to update all direct UI elements:

```python
def update_direct_ui_elements(self):
    """Update all UI elements created directly in the App class"""
    colors = self.theme_manager.COLORS
    
    # Status elements
    if hasattr(self, 'status_label'):
        self.status_label.color = colors["text"]["secondary"]
    if hasattr(self, 'loading_ring'):
        self.loading_ring.color = colors["bg"]["accent"]
        
    # File preview section
    if hasattr(self, 'preview_section'):
        # Update preview section title colors
        for container in self.preview_section.content.controls:
            if hasattr(container, 'content') and hasattr(container.content, 'controls'):
                # Update title text
                if len(container.content.controls) > 0:
                    title_text = container.content.controls[0]
                    title_text.color = colors["text"]["secondary"]
                
                # Update preview text field
                if len(container.content.controls) > 1 and hasattr(container.content.controls[1], 'content'):
                    preview_container = container.content.controls[1]
                    preview_container.bgcolor = colors["bg"]["input"]
                    preview_container.border = border.all(color=colors["border"]["default"])
                    
                    # Update the text field inside the preview container
                    if hasattr(preview_container, 'content'):
                        text_field = preview_container.content
                        text_field.text_style = TextStyle(
                            color=colors["text"]["secondary"],
                            size=14,
                            font_family="Consolas"
                        )
    
    # Buttons
    if hasattr(self, 'compare_button'):
        for button in self.compare_button.content.controls:
            button.style.color = colors["text"]["primary"]
            button.style.bgcolor = colors["bg"]["accent"]
    
    # Header elements
    if hasattr(self, 'history_button'):
        self.history_button.icon_color = colors["text"]["secondary"]
    if hasattr(self, 'settings_button'):
        self.settings_button.icon_color = colors["text"]["secondary"]
        
    # Results tabs (if using tabs UI)
    if hasattr(self, 'results_tabs') and self.results_tabs.tabs:
        for tab in self.results_tabs.tabs:
            if hasattr(tab, 'content') and hasattr(tab.content, 'content'):
                tab_column = tab.content.content
                if hasattr(tab_column, 'controls'):
                    for control in tab_column.controls:
                        if isinstance(control, ft.Text):
                            control.color = colors["text"]["secondary"]
                        elif isinstance(control, ft.TextField):
                            control.text_style = TextStyle(
                                color=colors["text"]["secondary"],
                                size=14,
                                font_family="Consolas",
                                weight=FontWeight.W_400
                            )
    
    # SnackBar
    if hasattr(self.page, 'snack_bar'):
        self.page.snack_bar.bgcolor = colors["bg"]["secondary"]
        if isinstance(self.page.snack_bar.content, ft.Text):
            self.page.snack_bar.content.color = colors["text"]["primary"]
    
    # Main layout containers
    self.main_card_container.bgcolor = colors["bg"]["secondary"]
```

### 2. Update ThemeManager's apply_theme Method

Modify the ThemeManager to call a separate method for App-level elements:

```python
def apply_theme(self, theme_key: str):
    """Change the current theme and notify all registered components"""
    self.current_theme = theme_key
    
    # Theme logic implementation...
    
    # Notify all registered components
    for component in self._registered_components:
        component.update_colors(self.COLORS)
    
    # Update app-level UI elements if app has the method
    if hasattr(self.app, 'update_direct_ui_elements'):
        self.app.update_direct_ui_elements()
    
    # Update page
    self.page.update()
```

### 3. Fix Theme Definitions

Ensure all themes have consistent color keys:

```python
# Update the light theme to include all keys from dark theme
"light": {
    "bg": {
        "primary": "#FFFFFF",     # Main background - pure white
        "secondary": "#F3F4F6",   # Card/container background - light gray
        "input": "#F9FAFB",       # Input field background
        "accent": "#3B82F6",      # Primary accent color
        "hover": "#60A5FA"        # Hover state color
    },
    "text": {
        "primary": "#111827",     # Main text - almost black
        "secondary": "#374151",   # Secondary/muted text
        "accent": "#2563EB",      # Accent text
        "disabled": "#9CA3AF"     # Disabled text
    },
    "border": {
        "default": "#E5E7EB",     # Default borders
        "accent": "#3B82F6",      # Accent borders
        "focus": "#60A5FA"        # Focus state borders
    },
    "changes": {
        "added": "#22C55E",       # Added items - green
        "removed": "#EF4444",     # Removed items - red
        "modified": "#FBBF24"     # Modified items - yellow
    },
    "dialog": {
        "background": "#FFFFFF",  # Dialog background
        "overlay": "rgba(0,0,0,0.3)" # Dialog overlay
    }
},
# Update AMOLED theme for truly black backgrounds
"amoled": {
    "bg": {
        "primary": "#000000",     # Pure black background
        "secondary": "#000000",   # Pure black secondary
        "input": "#121212",       # Slightly lighter black
        "accent": "#3B82F6",      # Blue accent
        "hover": "#60A5FA"        # Lighter blue hover
    },
    # Rest of AMOLED theme...
}
```

### 4. Add ThemeManager Reference in Constructor

Add this to the App's `__init__` method:

```python
def __init__(self, page: ft.Page, app_reference, config: Dict[str, Any]):
    self.page = page
    self.app = app_reference  # Store reference to app for callbacks
    self.config = config
    # Rest of initialization...
```

### 5. Update App's handle_theme_change Method

This ensures an immediate update to all UI elements:

```python
def handle_theme_change(self, e):
    """Handle theme mode changes"""
    theme = e.control.value
    self.theme_manager.apply_theme(theme)
    
    # Force update of all direct UI elements
    self.update_direct_ui_elements()
    
    # Force a full page update to refresh all elements
    self.page.update()
```

## Implementation Benefits

1. **Immediate Theme Updates**: All UI elements will update colors immediately when theme changes
2. **Consistent Experience**: Elements will maintain consistent styling across theme changes
3. **No Need for Restart**: Changes will apply without needing to restart the application
4. **Full Coverage**: Both component-based and direct UI elements will be updated

This implementation ensures that your AMOLED theme will have true black backgrounds, light theme will have white elements, and dark theme will use dark grays consistently across all UI components.

---

